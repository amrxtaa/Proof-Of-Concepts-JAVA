MULTITHREADING:
we can implement multithreading concept in java by using two ways:
a) by extending thread class which internally implememnts runnable(I).
b) by implementing Runnable(I) directly.
1. Thread scheduler is responsible to schdeule threads based on the algorithm. We cant expect the output in multithreading.
2. t.start();a new thread is created and is repsonsible to call start() of Thread class which internally calls run() method.
t.run(); no new thread will be created and main thread is responsible to call run() like a normal method call
start() of Thread class is responsible to register t thread with the Thread scheduler( no chance of starting a new thread in java without start(). 
start() method is the heart of multithreading.
3. Thread class start() invokes no-arg run().
4. if we are not overriding run() then Thread class run() will be called which has empty implementation(no output). It is recommeneded to override run() in our class.
5. if we override start() then it will be called like a normal method call and no new thraed will be created.(not recommeneded)
6. after starting a thread if we are trying to restart the same thread then we get RE: IllegalThreadStateException.
7. Runnable(I) is present in java.lang pakage and contains only one method i.e. run(). By implementing Runnable(i) we are calling start() of Thread class and then run() of myRunnable.
In MyThread2 class we have called run() indirectly of MyRunnable class by passing r as an object. IF not, then Thread class run() will be called.
8.  case study: myRunnable r=new myRunnable();
                 Thread t1=new Thread();
                 Thread t2=new Thread(r);
			- t1.start(); a new thread will be created and run() of THread class will be executed.
			- t1.run(); no new thread will be created and run() will be called like a normal method call.
			- t2.start(); a new thread will be created and run() of myRunnable class will be executed.
			- t2.run(); no new thread will be created and run() of myRunnable class will be executed like a normal method call.
            -r.start(); CE: myRunnable doesnt have start capablity.
            -r.run(); no new thread will be created and run() will be executed like a normal method call.
9. which approach is the best?
implements Runnable(I) is recommeneded because we can extend as many classes as we want along with implementing Runnable(i).
In 1st approach we can extend only one class always i.e. thread class hence we do miss inheritance concept.
10. size of the runtime stack is created by the JVM.
11. Every thread in java has a name. it could be provided by the JVM or by the programmer itself.
12.methods:
public final String getName(); to get the name of a thread
public final void setName(); to set the name of a thread
currentThread() is a static method of the Thread class. Thread.currentThread().getName() can be used to acess current thread.
13. Threads are numbered and named like: Thread-0, Thread-1 etc.
14. Every Thread in java has some priority. It could be default priority generated by the JVM or customized priority generated by the programmer.
15. They are numbered from 1 to 10.
1-- min_priority and 10-- max_priority
16. Thread.MIN_PRIORITY--1
    Thread.MAX_PRIORITY--10
    Thread.NORM_PRIORITY--5
17. Thread Scheduler will use the priorities while allocating processor. Thread having the highest priority gets the chance first.
18.If two threads have same priority then we cant expect the output as it completely depends on the scheduling algorithm.
19. methods to set and get the priority of the Thread:
   public final int getPriority();
   public final void setPriority(int p); // allowed values are 1 to 10.
20. the default priority for the main thread is 5 and for all other threads priority is been inherited from parent to child.
21. Some OS wont provide support for Thread Priorities.
22.  merhods to prevent thread execution:
      A) yield(): it causes to pass the control from current executing thread to the remaining threads of the same priority. If no waiting thread or low priority waiting threads then 
	  the current thread continues its exceution.
	  The thread except the one calling the yield() has high chance of getting executed first.
	  if a thread requires more processing time is recommeneded to call yield() frequently.
	  prototype: public static native yield();
B) join(): ifa thread wants to wait until the completion of any other thread then it may call join() on that thread. The current thread will enter into waiting state.
	     prototype: public final void join();
	     prototype: public final void join(long ms);
	     prototype: public final void join(long ms, int ns);
	the method is not staic so inorder to call the method we must use object reference.
	every join method must throw an Interuupted exception(checked exception). we must handle it either by try catch or by throws keyword else we get CE.The exception 
	is thrown because while the thread is waiting for some thread there may be a chance of another threads interuppting.
	case1: when the main thread waits for the child thread exceultion.
	case2: when the child thread waits for the main thread execution.
	case 3: when both the threads waits for the other thread exceution then the situtaion is said be in deadlock and both threads will enter into a deadlock state.
	case4: if a thread calls join() on the current thread only then it will also enter into deadlock state.
C) sleep():if a thread doesnt want to perform any action for some duration then it may go for sleep().
prototype: public static native void sleep(long ms) thorws IE
prototype: public static void sleep(long ms,int ns) thorws IE
    every sleep method must throw an Interuupted exception(checked exception). we must handle it either by try catch or by throws keyword else we get CE.The exception 
	is thrown because while the thread is waiting for some thread there may be a chance of another threads interuppting.
slide rotator in our presenation is an example of sleep() method.
23 how a thread may interrupt any other thread: by using interrupt()
a thread may interrupt a waiting/sleeping thread by calling interrupt() of Thread class.
public void interrupt();
when we call interuupt method the thread must be in waiting/sleeping state else there is no use to call this method.
in this case the call will be wasted.


24. Synchroization:
-synchronize modifier is only applicable for emthods and blocks but for variables and classes.
-if multiple objects are trying to operate on the same java object then there may be a chance of data inconsistency problem.
-if a method/block is declared as synchronized then at a time only one thread is allowed to excecute the method.
-advantage: resolves data inconsistency problem.
disadvantage: increases the waiting time of the threads and creates performance problems.(not reccommnended unless required)
-internally this concept is implemented using the LOCK concept. In java, every object has a unique lock.
-if a thread wants to execute a synchronize method then it has to get the lock of that object. when it gets the lock it may execute any synchronize method on that object.
 after the method exceution the thread releases the lock.
- aquirring and releasing the lock is the responsiblity of the JVM and user is not resposible for it.
- when a thread t1 is executing a synchronize method on the object, no other thread is allowed to execute any other synchronized method on that object. But non-Synchronized
methods can be executed sumultaneously.
-lock concept is implemented based on the object and not on the method.
-every object has two areas: 
non-synchronized                                                                            synchronized
this area can be accessed by any number of threads simultaneously.                          this area can be accessed by only one thread at a time.
where object state will not be changed like read() operation                                where object stae is said to be changed like update() etc.
eg. checkavailablity() in reservation system                                                eg: bookTicket()
-if multiple java threads are operating on the same java object then only synchronization is required else it is not needed.
-class-level lock:
every java object has a unique lock.
every java class has a unique lock known as class level lock. when a thread wants to execute static synchronized method of that class then we need class level lock.
once a method execution completed the thread automatocally releases the class level lock.
When a thread is executing a static synch method then no other thread is allowed to execute static synch method of that class simultaneouly.
other threads may execute these methods simulataneously:
a. instance methods
b. synch instance methods
c. sych methods